### 正则表达式

#### 	限定符（重复次数）

| 限定符 | 描述                                              | 实例                                                         |
| :----- | :------------------------------------------------ | :----------------------------------------------------------- |
| ？     | 问号之前的字符出现0次或者1次（?前的字符可有可无） | used?  可以匹配 use  和used                                  |
| *      | 星号之前的字符可以出现0次或者多次                 | ab*c  可以匹配 abbbc  abc  ac  ,不可以匹配adc                |
| +      | 加号之前的字符可以出现1次或者多次                 | ab+c 可以匹配 abbbc abc ,不可以匹配ac                        |
| {}     | 花括号之前的字符可以出现花括号内的次数（区间）    | ab{4}c 可以匹配abbbbc ，ab{4,6}c 可以匹配b出现4到6次，ab{2,}c 可以匹配b出现2次以上 |

想要用限定符作用于多个字符，可以用()将多个字符括起来，(ab)+ 可以匹配 ab abab ababab

#### 	或运算

a_(cat|dog) 其中，(cat|dog),可以匹配，cat或者dog

#### 	元字符

([a-zA_Z]){2,0}

正则表达式主要依赖于元字符。 ==元字符不代表他们本身的字面意思==，他们都有特殊的含义。一些元字符写在方括号中的时候有一些特殊的意思。以下是一些元字符的介绍：

| 元字符 | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| .      | 点号匹配任意单个字符除了换行符。                             |
| [ ]    | 字符种类。匹配方括号内的任意字符。                           |
| [^ ]   | 否定的字符种类。匹配除了方括号里的任意字符                   |
| *      | 匹配>=0个重复的在*号之前的字符。                             |
| +      | 匹配>=1个重复的+号前的字符。                                 |
| ?      | 标记?之前的字符为可选.                                       |
| {n,m}  | 匹配num个大括号之前的字符或字符集 (n <= num <= m).           |
| (xyz)  | 字符集，匹配与 xyz 完全相等的字符串.                         |
| \|     | 或运算符，匹配符号前或后的字符.                              |
| \      | 转义字符,用于匹配一些保留的字符 `[ ] ( ) { } . * + ? ^ $ \ |` |
| ^      | 从开始行开始匹配.                                            |
| $      | 从末端开始匹配.                                              |

#### 	简写字符集

正则表达式提供一些常用的字符集简写。如下:

| 简写 | 描述                                               |
| ---- | -------------------------------------------------- |
| .    | 除换行符外的所有字符                               |
| \w   | 匹配所有字母数字，等同于 `[a-zA-Z0-9_]`            |
| \W   | 匹配所有非字母数字，即符号，等同于： `[^\w]`       |
| \d   | 匹配数字： `[0-9]`                                 |
| \D   | 匹配非数字： `[^\d]`                               |
| \s   | 匹配所有空格字符，等同于： `[\t\n\f\r\p{Z}]`       |
| \S   | 匹配所有非空格字符： `[^\s]`                       |
| \f   | 匹配一个换页符                                     |
| \n   | 匹配一个换行符                                     |
| \r   | 匹配一个回车符                                     |
| \t   | 匹配一个制表符                                     |
| \v   | 匹配一个垂直制表符                                 |
| \p   | 匹配 CR/LF（等同于 `\r\n`），用来匹配 DOS 行终止符 |

#### 	标志

标志也叫模式修正符，因为它可以用来修改表达式的搜索结果。 这些标志可以任意的组合使用，它也是整个正则表达式的一部分。

| 标志 | 描述                                                  |
| ---- | ----------------------------------------------------- |
| i    | 忽略大小写。                                          |
| g    | 全局搜索。不仅仅返回第一个匹配的，而是返回全部        |
| m    | 多行修饰符：锚点元字符 `^` `$` 工作范围在每行的起始。 |



#### 	\1 \2 的用法

正则表达式中
‘\1’ 匹配的是 字符 ‘\1’ 。 (因为 ‘\’ 匹配字符 ‘\’ )
‘\2’ 匹配的是 字符 ‘\2’

单独斜杠的 \1 ， \2 就是反向引用了。
‘\1’ 匹配的是 所获取的第1个()匹配的引用。例如，’(\d)\1’ 匹配两个连续数字字符。如33aa 中的33
‘\2’ 匹配的是 所获取的第2个()匹配的引用。

| 方法         | 描述                                                         |
| :----------- | :----------------------------------------------------------- |
| [`exec`]     | 一个在字符串中执行查找匹配的RegExp方法，它返回一个数组（未匹配到则返回 null）。 |
| [`test`]     | 一个在字符串中测试是否匹配的RegExp方法，它返回 true 或 false。 |
| [`match`]    | 一个在字符串中执行查找匹配的String方法，它返回一个数组，在未匹配到时会返回 null。 |
| [`matchAll`] | 一个在字符串中执行查找所有匹配的String方法，它返回一个迭代器（iterator）。 |
| [`search`]   | 一个在字符串中测试匹配的String方法，它返回匹配到的位置索引，或者在失败时返回-1。 |
| [`replace`]  | 一个在字符串中执行查找匹配的String方法，并且使用替换字符串替换掉匹配到的子字符串。 |
| [`split`]    | 一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的 `String` 方法。 |

```java
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RegexMatches {
	
	public static void main(String args[]) {
		String str = "";
		String pattern = "(\\w+)\\.(\\w+)\\.(\\w+)";

		Pattern r = Pattern.compile(pattern);
		Matcher m = r.matcher(str);
      if(m.find())
      {
			System.out.println(m.group(0));
      }else{
         System.out.println("NO MATCH");
      }
	}

}
```

