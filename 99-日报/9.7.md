2021.9.7 魏俊泽 学习日志

1. 将css-dom-test添加至码云，以便管理查看。

2. 死磕36道算法题：

   1. 数据类型判断：终极方法：Object.prototype.toString().call()，使用call方法调用Object原型上的toString()方法将要检测数据类型的变量的构造函数打印出来结果为：[object Array] 类似格式，然后通过字符串处理函数分割得到我们想要的内容。

   2. 继承：

      1. 为什么要继承：我们在开发项目的过程中，面向对象编程中，很多方法可以复用，为了达到代码重用的目的，使用继承。
      2. 继承带来的问题：在继承的过程中，继承者和被继承者的共用区间问题，私有化问题和权限问题。
      3. 原型链继承：
         1. 原型链：在JavaScript中原型链是一个很重要的概念，js中一切数据类型的基础可以说都是对象Object，各种不同是通过原型链牵引出来的。实例是通过构造函数实例化出来的，而实例化出来的实例对象会有一个 ==__proto\_\_==属性，这个属性指向的对象与实例对象的构造函数的==prototype==属性指向的对象是同一引用地址。这个引用地址指向的对象称为实例对象的隐式原型，称为实例对象构造函数的显式原型。而构造函数的prototype指向的对象本身仍然是一个对象，是对象就会有==__proto\_\_==属性，这个属性就会指向该对象的隐式原型。由==__proto\_\_==属性链接起来的一个条链式的结构就是原型链，原型链的顶端是Object，它的==__proto\_\_==属性指向null。
         2. 相关特点：当我们访问一个实例对象的属性或者方法的时候，首先会在实例对象内查找，没有的话就会沿着原型链向上查找直到原型链末尾。hasOwnProperty()方法会限制在本实例对象内查找不会沿着原型链向上查找。
         3. 原型链继承：继承和原型链的特点都说清楚了，那么我们使用原型链的方式进行继承具体实现就可以理解了：
            1. 首先得有一个继承者和一个被继承者。继承者需要继承被继承者的属性和方法。
            2. 假设被继承者有一个a属性和一个b方法，由于继承者和被继承者都是构造函数，所以他们都有自己的显式原型prototype，这里被继承者的显式原型上还有一个方法c。
            3. 由于继承者的显式原型prototype应该是一个实例对象，在这里我们将被继承者的构造函数实例化，然后将实例化出的实例对象赋值给继承者的prototype显式原型，这样我们实例化一个继承者实例，这个继承者实例对象就能通过原型链向上查找的特点访问到被继承者的属性和方法了。
         4. 缺点：继承者可以修改被继承者的属性
      4. 构造函数继承：
         1. 使用构造函数继承，我们在继承者的构造函数中使用call方法调用被继承者的构造函数，就可以将被继承者的属性和方法clone一份到继承者里。
         2. 缺点：无法访问被继承者原型上的方法
      5. 组合继承：原型继承和构造函数继承都有自己的缺点。将两种方法组合起来可以互补。
         1. 在继承者的构造函数中使用call方法调用被继承者的构造函数，将属性和方法clone到继承者内。
         2. 让继承者的显式原型指向被继承者实例的==__proto\_\_==属性，即被继承者实例的隐式原型上
         3. 将继承者构造函数的显式原型prototype的构造函数 constructor指回继承者的构造函数（这里是因为重写了继承者的构造函数的显式原型prototype，会导致constructor指向混乱）

   3. 数组操作：

      1. 去重：ES5里使用indexof()记录首次出现的元素下标的特点挑出第一次出现的元素，达到去重的目的。ES6中借助Set数据类型一行解决 arr = [...new Set(arr)];
      2. 数组扁平化：如果已知深度直接使用 flat(n)可以实现扁平化。否则，ES5中可以通过递归的方式，逐步判定元素是否为数组类型，来决定是否进行扁平化处理，==核心代码：result = result.concat(flattenES5(arr[i]));==。ES6中使用展开操作符（...）的特点可以轻松实现==核心代码：result = [].concat(...result);==

      

