2021.9.8 魏俊泽 学习日志

1. 数字图像处理第三章
   1. 图像数字化的基本过程
      1. 采样：图像的数字化首先要进行采样，采样就是把在时间上和空间上连续的图像转化为离散的采样点。
      2. 量化：采样之后，模拟图像已经在时间和空间上离散化为像素，但是采样结果所得到的像素的值任然是连续量，必须把抽样所得的连续的量离散化为正数，这个过程就是量化。
      3. 均匀采样、均匀量化，非均匀采样、非均匀量化
      4. 工具：采样孔、图像扫描机构、光传感器、量化器、存储介质
      5. 采样和量化参数的选择：理论上采样点和量化等级越高，图像的质量越高
      6. 采样和量化参数选的的一般性原则：
         - 对于缓变的图像应该采用细量化，粗采样，以避免出现假轮廓。
         - 对于细节丰富的图像应该采用细采样，粗量化，以避免模糊。
   2. 采样定理（奈奎斯特采样定理、香农采样定理）
      1. 在进行模拟/数字采样时------------
      2. 数字图像的数据量
         1. 灰度图像的数据量
         2. 黑白图像的数据量
         3. 彩色图像的数据量
      3. 数字图像的分辨率
         1. 图像的空间分辨率
         2. 图像的灰度分辨率（色阶，灰度级数）
      4. 图像的类型
         - 灰度图像：从黑到白以某个分辨率
         - 索引图像
         - 真彩色图像
      5. 常见的图像文件格式
         - gif
         - png
         - jpeg（jpg）
         - BMP
   3. 图像的输入输出设备
2. 死磕36道算法题
   1. 对象的深浅克隆
      1. 三种数据结构的使用（Set、Map、WeakMap）
         1. Set：类似于数组，不过它内部元素都是唯一的，不可重复。它接受一个数组做参数用来初始化：let set = new Set(arr);
            1. set.add();
            2. set.delete();
         2. Map：类似于对象，不过JavaScript中键值只能是字符串，Map中对象函数等也可以当做键值。只有对同一个地址的引用才被认为是同一个键值。let map = new Map();
            1. map.size();
            2. map.set(key,value);
            3. map.has(key);
            4. map.get(key);
            5. map.delete(key);
            6. map.clear();
         3. WeakMap：类似于Map，不过它的键值只能是对象。
      2. 对象拷贝出现的原因：在JavaScript中对象是以引用的形式存储的，所以在复制对象的时候，不能使用简单的=====，否则复制出的对象并非是新对象，而是原来对象另一个引用，两个引用同一个对象。
      3. 浅拷贝就是只考虑我们要拷贝的这个变量的数据类型是对象，而不考虑这个对象的属性是否为对象数据类型行或者其他引用数据类型。
      4. 深拷贝：考虑对象属性为对象数据类型或者其他引用数据类型的情况，使用递归的方式处理。
      5. 深拷贝算法：
         1. 注意点：RegExp、Date、null、和循环引用的处理方式
         2. RegExp和Date很容易通过数据类型的判断方式判断出来，也可以使用constructor的name属性判断。
         3. 循环引用的处理方式：使用一个WeakMap数据结构，将对象内部为引用类型的属性全都加入这个WeakMap数据机构中，利用WeakMap区分键值是根据是否为同一引用地址进行的特点，在深拷贝开始时使用WeakMap.has(key)方法，判断是否已经引用过此地址，是则存在循环引用，直接返回引用地址即可，不在继续clone。
   2. 事件总线（订阅发布）
      1. 使用ES6新增的class创建事件总线，来模拟事件订阅和发布过程。
         1. EventEmitter类，拥有一个构造函数，构造函数内定义了cache对象，存储了订阅者和对应的订阅事件函数。
         2. EventEmitter类中有一个绑定订阅者事件函数on(name, fn)，参数分别是订阅者和事件函数。内部逻辑就是判定是否已经是订阅者，是则在它的事件数组中加入本事件函数，不是则创建订阅者，然后再加入事件函数。
         3. EventEmitter类中有一个解除绑定订阅者事件函数off(name, fn)，参数分别是订阅者和要解绑的事件函数。逻辑是找到数组中对应的事件元素的下标，并删除。
         4. EventEmitter类中有一个事件发布函数emit(name, once = false, ...args)，参数分别是要发布给的订阅者、是否为一次订阅、事件参数。逻辑大致是依次执行订阅者的事件函数，函数参数是...args。然后判断once，是否执行结束取消订阅。